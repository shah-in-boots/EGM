### Class Definitions ----

#' Electrogram data class from electrophysiology studies
#'
#' @description This class serves as a combinatorial class to describe
#'   cardiovascular electrical signal data in R. It is based off of the formats
#'   available in WFDB, but has been formatted for ease of use within the `R`
#'   ecosystem. An `EGM` object contains three components in a list:
#'
#'   * signal data in multiple channels
#'
#'   * header information
#'
#'   * annotation labels at specified time points
#'
#'   These components help to navigate, and visualize data. The `EGM` class is
#'   the backbone for working with WFDB objects in R, and provides an interface
#'   for integrating or converting other raw signal data to a WFDB format.
#'
#' @details The individual components of the class are further defined in their
#'   respective children functions [signal_table()], [header_table()],
#'   [annotation_table()]. They are very simple classes that build upon the
#'   `data.table` class that allow for class safety checks when working with
#'   different data types (particularly WFDB).
#'
#'   __IMPORTANT__: The `EGM` class can be built from ground-up by the user,
#'   however it is primarily generated for the user using the other read/write
#'   functions, such as [read_bard()] or [read_wfdb()].
#'
#' @returns An object of class `EGM` that is always a list of the above three
#'   components. Oftentimes, the `annotation_table` object may be missing, and
#'   it is replaced with an empty table as a place holder.
#'
#' @param x An `EGM` object, typically generated by the [EGM()] function, to be
#'   used with support functions (e.g. [is_EGM()]
#'
#' @param signal A `signal_table` object generated by the [signal_table()]
#'   function
#'
#' @param header A `header_table` object generated by the [header_table()]
#'   function
#'
#' @param annotation Either a single `annotation_table` object generated by the
#'   [annotation_table()] function (deprecated), or a named list of
#'   `annotation_table` objects for multiple annotators (recommended)
#'
#' @param ... Additional arguments to be passed to the function
#'
#' @name EGM
#' @export
EGM <- function(
  signal = signal_table(),
  header = header_table(),
  annotation = annotation_table(),
  ...
) {
  # Signal data will be in multi-channel format for EPS data, e.g. data.table
  # Header will be  a list

  # Validate annotation format
  if (inherits(annotation, "annotation_table")) {
    # Valid - will be converted in new_EGM()
  } else if (is.list(annotation)) {
    # List format - validate that all elements are annotation_tables
    if (length(annotation) > 0) {
      valid <- all(vapply(annotation, inherits, logical(1), "annotation_table"))
      if (!valid) {
        stop(
          "All elements in annotation list must be annotation_table objects",
          call. = FALSE
        )
      }
      # Ensure list is named
      if (is.null(names(annotation)) || any(names(annotation) == "")) {
        stop(
          "annotation list must be named with annotator identifiers",
          call. = FALSE
        )
      }
    }
  } else {
    stop(
      "annotation must be either an annotation_table or a named list of annotation_table objects",
      call. = FALSE
    )
  }

  new_EGM(signal, header = header, annotation = annotation)
}

#' @keywords internal
new_EGM <- function(
  signal = signal_table(),
  header = header_table(),
  annotation = annotation_table(),
  ...
) {
  # Convert single annotation_table to named list
  if (inherits(annotation, "annotation_table")) {
    annotator_name <- attr(annotation, "annotator")
    if (length(annotator_name) > 0 && nzchar(annotator_name)) {
      # Named list using annotator attribute
      annotation <- setNames(list(annotation), annotator_name)
    } else {
      # Empty/unnamed annotation - wrap in unnamed list
      annotation <- list(annotation)
    }
  }

  # Signal will become a data frame (coerced into a data table)
  structure(
    list(
      signal = signal,
      header = header,
      annotation = annotation
    ),
    class = c('EGM', 'list')
  )
}

#' @export
format.EGM <- function(x, ...) {
  hea <- x$header
  rec <- attributes(hea)$record_line
  ann <- x$annotation # May be empty table or list

  cat('<Electrogram>\n')
  cat('-------------------\n')
  cat('Recording Duration: ', rec$samples / rec$frequency, 'seconds\n')
  cat('Recording frequency ', rec$frequency, ' hz\n')
  cat('Number of channels: ', rec$number_of_channels, '\n')
  cat('Channel Names: ', paste(hea$label), '\n')

  # Annotation is always a list now
  if (is.list(ann) && length(ann) > 0) {
    annotators <- names(ann)
    if (!is.null(annotators) && any(nzchar(annotators))) {
      counts <- vapply(ann, nrow, integer(1))
      cat(
        'Annotators: ',
        paste0(annotators, ' (', counts, ' annotations)', collapse = ', '),
        '\n'
      )
    } else {
      cat('Annotators: none\n')
    }
  } else {
    cat('Annotators: none\n')
  }
}

#' @export
print.EGM <- function(x, ...) {
  format(x)
}

#' @export
#' @rdname EGM
is_EGM <- function(x) {
  inherits(x, "EGM")
}

#' @keywords internal
#' Get a single annotation table from EGM object
#' If multiple annotators exist, returns the first one with a message
.get_single_annotation <- function(EGM_obj) {
  ann <- EGM_obj$annotation

  # Handle empty list
  if (length(ann) == 0) {
    return(annotation_table())
  }

  # Annotation is always a list now
  if (length(ann) == 1) {
    return(ann[[1]])
  } else {
    # Multiple annotations - return first with message
    message(
      "Multiple annotators found: ",
      paste(names(ann), collapse = ", "),
      ". Using '",
      names(ann)[1],
      "'. ",
      "Use get_annotation() to specify which annotator to use."
    )
    return(ann[[1]])
  }
}

# Helper functions -------------------------------------------------------------

#' Extract raw signal data from an `EGM` object
#'
#' @description Raw signal data may be all that is required, particularly when
#' storing or manipulating data, or for example, feeding it into an analytical
#' pipeline. This means the extraneous elements, such as the *meta* information,
#' may be unnecessary. This function helps to strip away and extract just the
#' signal data itself and channel names.
#'
#' @details The options to return the data vary based on need. The data can be
#' extracted as follows:
#'
#' * `data.frame` containing an equal number of rows to the number of samples, with each column named after the recording channel it was derived from. Data frames, as they are columnar by nature, will also include the sample index position.
#'
#' * `matrix` containing an equal number of rows to the number of samples, with each column named after the recording channel it was derived from
#'
#' * `array` containing individual vectors of signal, each named after the channel they were derived from
#'
#' @param object An `EGM` object that contains the signal data to be extracted
#'
#' @param data_format A `character` choice of either *data.frame* (default),
#'   *matrix*, or *array* that tells how the data should be structured.
#'   Further explanation in the details.
#'
#' @param ... Additional arguments to be passed to the function
#'
#' @returns An object as described by the __format__ option
#'
#' @export
extract_signal <- function(
  object,
  data_format = c("data.frame", "matrix", "array"),
  ...
) {
  stopifnot(
    "Requires object of `EGM` class for evaluation" = inherits(object, "EGM")
  )

  data_format <- match.arg(data_format)

  sig <- data.frame(object$signal)
  signal_only <- sig[, -1, drop = FALSE]

  switch(
    data_format,
    array = {
      channel_names <- names(signal_only)
      out <- array(
        data = as.matrix(signal_only),
        dim = c(nrow(signal_only), ncol(signal_only)),
        dimnames = list(NULL, channel_names)
      )
    },
    matrix = {
      out <- as.matrix(signal_only)
    },
    data.frame = {
      out <- sig
    }
  )

  out
}
