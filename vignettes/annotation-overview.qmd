---
title: "Understanding Annotations"
format:
  html:
    toc: true
    toc-depth: 3
    toc-location: left
    number-sections: true
vignette: >
  %\VignetteIndexEntry{Understanding WFDB Annotations}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
knitr:
  opts_chunk:
    collapse: true
    comment: '#>'
---

```{r}
#| label: setup
library(EGM)
```

<!-- 
Introduction will go here. First start with WFDB annotation standard. Need to describe the current standards for how annotations are documented in WFDB. The general structure will be...

- Give an example of the annotation table and the required elements
- Show the overall types of annotations that are standard, e.g. the `.surface_annotations`, grouped by the type of annotations that are available to help it be easy to understand
-->

# Electrocardiogram Annotations

## WFDB Annotation Standards

The WFDB (Waveform Database) software package provides a standardized system for annotating cardiac signals, predominately surface electrocardiogram (**ECG**) data.
Annotations are polymorphic, meaning multiple annotation sets can be applied to a single signal dataset.
The limitation is that these are constrained to physiological events associated with surface ECGs. 

### Annotation Table Structure

All WFDB-compatible annotations in the `{EGM}` package are stored as `annotation_table` objects. 
The columns are type-specific, which allows them to be easily stored.
These tables contain the following required columns:

- **annotator**: Name of the annotation function or creator (e.g., "sqrs", "ecgpuwave", "manual")
- **time**: Time stamp constructed from sample number and sampling frequency (format: HH:MM:SS.mmm)
- **sample**: Integer index of the annotation position in the signal
- **type**: Single character symbol describing the annotation type (see annotation types below)
- **subtype**: Single character providing additional classification
- **channel**: Integer indicating which signal channel the annotation applies to
- **number**: Additional numeric qualifier providing context-specific information

```{r}
# Create annotations for detected R-peaks
# Example
ann <- annotation_table(
  annotator = "qrs",
  sample = c(100, 350, 600, 850),
  type = "N",
  frequency = 250,
  channel = 0
)

# Print
ann
```

## Standard ECG Annotation Types

The WFDB standard defines 41 annotation types for surface electrocardiograms. 
These annotations can be broadly grouped into several categories:

### Beat Annotations

Beat annotations mark individual cardiac cycles and their characteristics:

```{r}
# Load internal annotation data
beat_symbols <- c("N", "L", "R", "a", "V", "F", "J", "A", "S", "E", "j", "/", "Q", "~")
beat_labels <- EGM:::.surface_annotations[EGM:::.surface_annotations$symbol %in% beat_symbols, ]

knitr::kable(
  beat_labels[, c("symbol", "mnemonic", "description")],
  col.names = c("Symbol", "Mnemonic", "Description"),
  row.names = FALSE,
  caption = "Beat Annotation Types"
)
```

**Key beat types:**

- **N (NORMAL)**: Normal sinus beat
- **V (PVC)**: Premature ventricular contraction
- **A (APC)**: Atrial premature contraction
- **L/R (LBBB/RBBB)**: Bundle branch block beats
- **F (FUSION)**: Fusion of ventricular and normal beat
- **/ (PACE)**: Paced beat

### Waveform Boundary Annotations

These mark the beginning, peak, and end of ECG waveforms:

```{r}
wave_symbols <- c("p", "t", "u", "(", ")")
wave_labels <- EGM:::.surface_annotations[EGM:::.surface_annotations$symbol %in% wave_symbols, ]

knitr::kable(
  wave_labels[, c("symbol", "mnemonic", "description")],
  col.names = c("Symbol", "Mnemonic", "Description"),
  row.names = FALSE,
  caption = "Waveform Boundary Annotations"
)
```


### Rhythm and Signal Quality Annotations

```{r}
rhythm_symbols <- c("+", "|", "s", "T", "~", "x")
rhythm_labels <- EGM:::.surface_annotations[EGM:::.surface_annotations$symbol %in% rhythm_symbols, ]

knitr::kable(
  rhythm_labels[, c("symbol", "mnemonic", "description")],
  col.names = c("Symbol", "Mnemonic", "Description"),
  row.names = FALSE,
  caption = "Rhythm and Signal Quality Annotations"
)
```

### Specialized Annotations

```{r}
special_symbols <- c("*", "D", "\"", "=", "!", "[", "]", "@", "r", "^", "B", "e", "n", "f")
special_labels <- EGM:::.surface_annotations[EGM:::.surface_annotations$symbol %in% special_symbols, ]

knitr::kable(
  special_labels[, c("symbol", "mnemonic", "description")],
  col.names = c("Symbol", "Mnemonic", "Description"),
  row.names = FALSE,
  caption = "Specialized Annotations"
)
```

## Common Annotation File Types

When working with WFDB files, annotations are stored with specific file extensions that indicate the annotator used:

- **`.atr`**: Manually reviewed and corrected reference annotations
- **`.ann`**: General annotation file
- **`.ecgpuwave`**: Surface ECG wave boundaries (P, QRS, T waves) generated by the ecgpuwave algorithm
- **`.sqrs`, `.wqrs`, `.gqrs`**: R-peak detections from different QRS detection algorithms

## Accessing All Standard Annotations

The complete list of standard WFDB annotations can be accessed using:

```{r, eval=FALSE}
# View all standard ECG annotation types
wfdb_annotation_labels()

# Filter for specific symbols
wfdb_annotation_labels(symbol = c("N", "V", "A"))

# Decode annotations in an existing annotation table
ann <- annotation_table(
  annotator = "example",
  sample = c(100, 200),
  type = c("N", "V")
)

# Add human-readable descriptions
wfdb_annotation_decode(ann)
```

## Example: Working with ECG Annotations

Here's a practical example of reading, interpreting, and visualizing ECG annotations:

```{r, eval=FALSE}
# Read an ECG with annotations
record_path <- system.file('extdata', package = 'EGM')
ecg <- read_wfdb(
  record = "muse-sinus",
  record_dir = record_path
)

# Read associated annotations (if they exist)
ann <- read_annotation(
   record = "muse-sinus",
   annotator = "ecgpuwave",
   record_dir = record_path
)

# Decode annotation types
ann_decoded <- wfdb_annotation_decode(ann)
head(ann_decoded)
```

# Working with Multiple Annotators

A key feature of the WFDB system is the ability to apply multiple independent annotation sets to a single recording. This is essential for comparing different automated algorithms, validating manual annotations, or analyzing different physiological features simultaneously.

## Reading Multiple Annotators

The `{EGM}` package supports reading multiple annotators in a single operation:

```{r, eval=FALSE}
# Read a single annotator (traditional approach)
ann_single <- read_annotation(
  record = "300",
  record_dir = "path/to/data",
  annotator = "ecgpuwave"
)

# Read multiple annotators simultaneously
ann_multiple <- read_annotation(
  record = "300",
  record_dir = "path/to/data",
  annotator = c("ecgpuwave", "atr", "wqrs")
)

# Returns a named list of annotation_table objects
names(ann_multiple)
# [1] "ecgpuwave" "atr" "wqrs"

# Access individual annotators
ann_multiple$ecgpuwave
ann_multiple$atr
```

## Reading Complete Records with Multiple Annotators

You can also read an entire WFDB record with multiple annotations in one call:

```{r, eval=FALSE}
# Read signal, header, and multiple annotations together
record <- read_wfdb(
  record = "300",
  record_dir = "path/to/data",
  annotator = c("ecgpuwave", "atr")
)

# The egm object now contains multiple annotators
print(record)
# <Electrogram>
# -------------------
# Recording Duration: 650 seconds
# Recording frequency: 360 hz
# Number of channels: 2
# Channel Names: MLII V5
# Annotators: ecgpuwave (4238 annotations), atr (2548 annotations)
```

## Helper Functions for Multi-Annotator Workflows

### List Available Annotators

```{r, eval=FALSE}
# Get names of all annotators in an egm object
annotators <- list_annotators(record)
# [1] "ecgpuwave" "atr"
```

### Extract Specific Annotators

```{r, eval=FALSE}
# Extract a specific annotator from an egm object
ecg_ann <- get_annotation(record, "ecgpuwave")

# Extract all annotators as a list
all_ann <- get_annotation(record)

# This will error if the annotator doesn't exist
# get_annotation(record, "nonexistent")  # Error!
```

### Merge Multiple Annotators

For comparative analysis, you may want to combine multiple annotators into a single table:

```{r, eval=FALSE}
# Merge all annotators into one table
merged <- merge_annotations(record)

# The result includes an 'annotator' column to identify the source
head(merged)
#       time   sample type subtype channel number annotator
# 1 00:00:01      360    N       0       0      0 atr
# 2 00:00:01      361    (       0       0      1 ecgpuwave
# 3 00:00:01      377    )       0       0      1 ecgpuwave
# 4 00:00:02      720    N       0       0      0 atr
# ...

# Merge only specific annotators
merged_subset <- merge_annotations(record, annotators = c("ecgpuwave"))

# You can also merge from a list of annotation_table objects
ann_list <- read_annotation(
  record = "300",
  annotator = c("ecgpuwave", "atr")
)
merged_from_list <- merge_annotations(ann_list)
```

## Use Cases for Multiple Annotators

### Algorithm Comparison

Compare the performance of different R-peak detection algorithms:

```{r, eval=FALSE}
# Read multiple QRS detection algorithms
qrs_detectors <- read_annotation(
  record = "300",
  annotator = c("sqrs", "wqrs", "gqrs", "atr")  # atr is manual reference
)

# Merge for comparison
all_detections <- merge_annotations(qrs_detectors)

# Filter to N-type beats only
normal_beats <- all_detections[type == "N"]

# Compare detection counts
table(normal_beats$annotator)
#  atr gqrs sqrs wqrs
# 2500 2487 2501 2498
```

### Multi-Channel Annotations

Different annotators may apply to different signal channels:

```{r, eval=FALSE}
# Read multi-channel record with channel-specific annotations
record <- read_wfdb(
  record = "multi-lead",
  annotator = c("lead_I_qrs", "lead_II_qrs", "global_rhythm")
)

# Extract annotations for specific channel
lead_I_ann <- get_annotation(record, "lead_I_qrs")
lead_I_annotations <- lead_I_ann[channel == 0]  # Assuming lead I is channel 0
```

### Combined Feature Extraction

Use different annotators for different physiological features:

```{r, eval=FALSE}
# Read beat detection and wave delineation separately
features <- read_annotation(
  record = "300",
  annotator = c("atr", "ecgpuwave")
  # atr: R-peaks
  # ecgpuwave: P/QRS/T wave boundaries
)

# Merge to analyze complete cardiac cycles
all_features <- merge_annotations(features)

# Find QRS onset markers from ecgpuwave
qrs_onset <- all_features[type == "(" & number == 1]  # WFON for QRS

# Find corresponding R-peaks from atr
r_peaks <- all_features[type == "N" & annotator == "atr"]
```

## Best Practices

1. **Consistent Naming**: Use descriptive annotator names that indicate their purpose

2. **Validate Compatibility**: Ensure annotators are compatible with your signal channels

3. **Memory Considerations**: Only load the annotators you need for your analysis

4. **Comparison Workflows**: When comparing annotators, use `merge_annotations()` for aligned time-series analysis

5. **Documentation**: Keep track of which annotator serves which purpose in your analysis pipeline

# Intracardiac Electrogram Annotations

<!--
This section is on the intracardiac annotation options. The intracardiac has to have a similar and compatible structure, with the same variable types.

The type includes:

- a = Atrial
- v = Ventricular
- h = His bundle recording
- f = Fascicular potential

The subtypes 
-->

This is a work in progress, where we aim to define and implement a comprehensive set of annotations for intracardiac electrograms that are compatible with the standard WFDB annotation system.



# Examples

## `ecgpuwave`

One of the common annotators used, called [`ecgpuwave`](https://physionet.org/content/ecgpuwave/1.3.4/), demonstrates how the annotation system is leveraged.

The standard labels are used:

- **p (PWAVE)**: P-wave peak
- **t (TWAVE)**: T-wave peak
- **( (WFON)**: Waveform onset
- **) (WFOFF)**: Waveform end

When using waveform boundary annotations like `(` and `)`, the **number** column specifies which waveform:

- 0 = P wave
- 1 = QRS complex
- 2 = T wave

For T-wave annotations (`t`), the **number** column describes morphology:

- 0 = Normal
- 1 = Inverted
- 2 = Positive
- 3 = Negative
- 4 = Biphasic (negative-positive)
- 5 = Biphasic (positive-negative)

# Registration

When reviewing annotations, the `{EGM}` system allows for all annotation types to be included, whether or not they conform with the WFDB annotator standards. 
The `annotation_table` class allows any __annotator__ type to be read in.

However the `{EGM}` package would like to allow for editing of annotations and writing annotations, which requires some level of standardization (particularly when introducing a new annotation labels to intracardiac data). 

To allow for editing on writing annotations (either through an algorithm approach or manual edits), several rules are inherent:

1. An `annotator` class is required 


